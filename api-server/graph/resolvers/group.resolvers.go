package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"

	"github.com/pluralsh/oauth-playground/api-server/graph/generated"
	"github.com/pluralsh/oauth-playground/api-server/graph/model"
)

// TODO: deleting a group might not be deleting all the relationships in keto. This is probably a problem elsewhere too.
// Getting the group bound to a user fails with the below error. Indicating that the user has a relation to this group but the group itself does not exists in the organization in keto.
// ERROR   clients.GetUserGroups   failed to get group     {"ID": "acb80a94-75b2-4378-b72e-ae6d1181f4c9", "Name": "test5", "error": "group does not exist in keto"}

// Members is the resolver for the members field.
func (r *groupResolver) Members(ctx context.Context, obj *model.Group) ([]*model.User, error) {
	return r.C.GetGroupMembersInKeto(ctx, obj.Name)
}

// Group is the resolver for the group field.
func (r *mutationResolver) Group(ctx context.Context, name string, members []string) (*model.Group, error) {
	if name == "" {
		return nil, fmt.Errorf("group name cannot be empty")
	}

	var sanitizedMembers []string
	for _, member := range members {
		if member != "" {
			sanitizedMembers = append(sanitizedMembers, member)
		}
	}

	return r.C.MutateGroup(ctx, name, sanitizedMembers)
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, name string) (*model.Group, error) {
	if name == "" {
		return nil, fmt.Errorf("group name cannot be empty")
	}
	return r.C.DeleteGroup(ctx, name)
}

// ListGroups is the resolver for the listGroups field.
func (r *queryResolver) ListGroups(ctx context.Context) ([]*model.Group, error) {
	return r.C.ListGroupsInKeto(ctx)
}

// Group returns generated.GroupResolver implementation.
func (r *Resolver) Group() generated.GroupResolver { return &groupResolver{r} }

type groupResolver struct{ *Resolver }
