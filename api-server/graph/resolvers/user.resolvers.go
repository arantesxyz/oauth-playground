package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"

	"github.com/pluralsh/oauth-playground/api-server/graph/generated"
	"github.com/pluralsh/oauth-playground/api-server/graph/model"
)

// ListUsers is the resolver for the listUsers field.
func (r *queryResolver) ListUsers(ctx context.Context) ([]*model.User, error) {
	log := r.C.Log.WithName("ListUsers")
	users, resp, err := r.C.KratosClient.IdentityApi.ListIdentities(ctx).Execute()
	if err != nil || resp.StatusCode != 200 {
		return nil, fmt.Errorf("failed to list users: %w", err)
	}

	var output []*model.User

	for _, user := range users {

		var email string
		var name string

		if val, ok := user.Traits.(map[string]interface{})["email"]; ok {
			if foundEmail, ok := val.(string); ok {
				email = foundEmail
			} else {
				log.Error(err, "Error when parsing email")
			}
		}

		if val, ok := user.Traits.(map[string]interface{})["name"]; ok {
			first, firstFound := val.(map[string]interface{})["first"]
			last, lastFound := val.(map[string]interface{})["last"]

			if firstName, ok := first.(string); ok {
				if lastName, ok := last.(string); ok {
					if firstFound && lastFound {
						name = firstName + " " + lastName
					}
				}
			}
		}

		output = append(output, &model.User{
			ID:    user.Id,
			Email: email,
			Name:  &name,
		})

	}
	return output, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
